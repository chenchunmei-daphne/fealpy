from .nodetype import CNodeType, PortConf, DataType

__all__ = ["VPDecoupling", "UDecoupling"]

class VPDecoupling(CNodeType):
    r"""Decouple velocity and pressure components from the combined output vector.

    Inputs:
        out (tensor): Combined output vector containing velocity and pressure components.
        uspace (space): Function space for the velocity field.
        mesh (mesh): Computational mesh.
    Outputs:
        uh (tensor): Numerical velocity field.
        u_x (tensor): x-component of the velocity field.
        u_y (tensor): y-component of the velocity field.
        ph (tensor): Numerical pressure field.
    """
    TITLE: str = "速度-压力解耦"
    PATH: str = "后处理.解耦"
    DESC: str = """该节点用于将包含速度和压力分量的联合输出向量进行解耦，提取速度场及其各分量与压力场，
                便于后续的流体力学结果分析与可视化处理。"""
    INPUT_SLOTS = [
        PortConf("out", DataType.TENSOR, title="结果"),
        PortConf("uspace", DataType.SPACE, title="速度函数空间"),
        PortConf("mesh", DataType.MESH, title="网格")
    ]
    OUTPUT_SLOTS = [
        PortConf("uh", DataType.TENSOR, title="速度数值解"),
        PortConf("ph", DataType.TENSOR, title="压力数值解"),
        PortConf("uh_x", DataType.TENSOR, title="速度x分量数值解"),
        PortConf("uh_y", DataType.TENSOR, title="速度y分量数值解"),
        PortConf("uh_z", DataType.TENSOR, title="速度z分量数值解")
    ]

    @staticmethod
    def run(out, uspace, mesh):
        from fealpy.backend import backend_manager as bm
        ugdof = uspace.number_of_global_dofs()
        NN = mesh.number_of_nodes()
        uh = out[:ugdof]
        uh = uh.reshape(mesh.GD,-1).T
        uh = uh[:NN,:]
        uh_x = uh[..., 0]
        uh_y = uh[..., 1]
        if mesh.GD == 3:
            uh_z = uh[..., 2]
        else:
            uh_z = bm.zeros_like(uh_x)
        ph = out[ugdof:]

        return uh, ph, uh_x, uh_y, uh_z


class UDecoupling(CNodeType):
    r"""Decouple translational and rotational displacement components 
    from the combined output vector.
    
    Inputs:
        out (tensor): Combined displacement vector of all nodes. 
        node_ldof (INT): Number of local degrees of freedom (DOFs) per node. 
        type (MENU): Type of finite element.
            
    Outputs:
        uh (tensor): Translational displacement field.
        theta (tensor): Rotational displacement field.
    """
    TITLE: str = "位移后处理"
    PATH: str = "后处理.位移"
    DESC: str = "将模型的平动位移和转动位移做后处理"
    INPUT_SLOTS = [
        PortConf("out", DataType.TENSOR, 1, desc="求解器输出的原始位移向量", title="位移向量"),
        PortConf("node_ldof", DataType.MENU, 0, desc="节点的自由度个数", title="自由度长度", default=2, items=[2, 3, 4, 6]),
        PortConf("type", DataType.MENU, 0, desc="单元的类型", title="单元类型", default="Truss", items=["Truss", "Euler_beam", "Timo_beam"]),
    ]
    OUTPUT_SLOTS = [
        PortConf("uh", DataType.TENSOR,  title="平动位移"),
        PortConf("theta", DataType.TENSOR, title="转动位移"),
    ]

    @staticmethod
    def run(out, node_ldof, type):
        
        u = out.reshape(-1, node_ldof)
        if type == "Truss":
            uh = u
        elif type == "Euler_beam":
            uh = u[:, :1]
            theta = u[:, 1:]
        elif type == "Timo_beam":
            uh = u[:, :3]
            theta = u[:, 3:]
        else: 
            raise ValueError(f'post-processing for this type of displacement is not supported yet.')

        return uh, theta

class TrussPostprocess(CNodeType):
    r"""Calculates the displacement of each node and the strain and stress of each rod element 
    based on the raw displacement vector output by the solver and material parameters.

    Inputs:
        uh (tensor): Raw displacement vector output by the solver.
        mesh (mesh): Mesh containing node and cell information.
        E (float): Elastic modulus of the rod.
    Outputs:
        strain (tensor): Strain of each rod element.
        stress (tensor): Stress of each rod element.
        u (tensor): Reshaped displacement tensor (NN, GD).
    """
    TITLE: str = "结果后处理"
    PATH: str = "后处理.位移应力应变"
    DESC: str = "根据求解器输出的桁架原始位移向量和材料参数，计算每个节点的位移和每个杆单元的应变应力"
    INPUT_SLOTS = [
        PortConf("uh", DataType.TENSOR, 1, desc="求解器输出的原始位移向量", title="位移向量"),
        PortConf("mesh", DataType.MESH, 1, desc="包含节点和单元信息的网格", title="网格"),
        PortConf("E", DataType.FLOAT, 1, desc="杆的弹性模量", title="弹性模量"),
    ]
    OUTPUT_SLOTS = [
        PortConf("strain", DataType.TENSOR, desc="每个杆单元的应变", title="应变"),
        PortConf("stress", DataType.TENSOR, desc="每个杆单元的应力", title="应力"),
        PortConf("u", DataType.TENSOR, desc="重塑后的位移张量 (NN, GD)", title="位移")
    ]

    @staticmethod
    def run(uh, mesh, E):
        from fealpy.backend import backend_manager as bm
        
        u = uh.reshape(-1, 3) 

        edge = mesh.entity('edge')
        l = mesh.edge_length()
        tan = mesh.edge_tangent()
        unit_tan = tan / l.reshape(-1, 1)

        u_edge = u[edge]
        delta_u = u_edge[:, 1, :] - u_edge[:, 0, :]
        delta_l = bm.einsum('ij,ij->i', delta_u, unit_tan)
        strain = delta_l / l
        stress = E * strain
        
        return strain, stress, u
